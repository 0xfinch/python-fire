{
    "docs": [
        {
            "location": "/", 
            "text": "Python Fire \n\n\nPython Fire is a library for automatically generating command line interfaces\n(CLIs) from absolutely any Python object.\n\n\n\n\nPython Fire is a simple way to create a CLI in Python. \n[1]\n\n\nPython Fire is a helpful tool for developing and debugging Python code. \n[2]\n\n\nPython Fire helps with exploring existing code or turning other people's code\ninto a CLI. \n[3]\n\n\nPython Fire makes transitioning between Bash and Python easier. \n[4]\n\n\nPython Fire makes using a Python REPL easier by setting up the REPL with the\nmodules and variables you'll need already imported and created. \n[5]\n\n\n\n\nInstallation\n\n\nTo install Python Fire with pip, run: \npip install fire\n\n\nTo install Python Fire with conda, run: \nconda install fire -c conda-forge\n\n\nTo install Python Fire from source, first clone the repository and then run:\n\npython setup.py install\n\n\nBasic Usage\n\n\nYou can call \nFire\n on any Python object:\n\nfunctions, classes, modules, objects, dictionaries, lists, tuples, etc.\nThey all work!\n\n\nHere's an example of calling Fire on a class.\n\n\nimport fire\n\nclass Calculator(object):\n  \nA simple calculator class.\n\n\n  def double(self, number):\n    return 2 * number\n\nif __name__ == '__main__':\n  fire.Fire(Calculator)\n\n\n\n\nThen, from the command line, you can run:\n\n\npython calculator.py double 10  # 20\npython calculator.py double --number=15  # 30\n\n\n\n\nTo learn how Fire behaves on functions, objects, dicts, lists, etc, and to learn\nabout Fire's other features, see the \nUsing a Fire CLI page\n.\n\n\nFor additional examples, see \nThe Python Fire Guide\n.\n\n\nWhy is it called Fire?\n\n\nWhen you call \nFire\n, it fires off (executes) your command.\n\n\nWhere can I learn more?\n\n\nPlease see \nThe Python Fire Guide\n.\n\n\nReference\n\n\n\n\n\n\n\n\nSetup\n\n\nCommand\n\n\nNotes\n\n\n\n\n\n\n\n\n\n\ninstall\n\n\npip install fire\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCreating a CLI\n\n\nCommand\n\n\nNotes\n\n\n\n\n\n\n\n\n\n\nimport\n\n\nimport fire\n\n\n\n\n\n\n\n\nCall\n\n\nfire.Fire()\n\n\nTurns the current module into a Fire CLI.\n\n\n\n\n\n\nCall\n\n\nfire.Fire(component)\n\n\nTurns \ncomponent\n into a Fire CLI.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nUsing a CLI\n\n\nCommand\n\n\nNotes\n\n\n\n\n\n\n\n\n\n\nHelp\n\n\ncommand -- --help\n\n\n\n\n\n\n\n\nREPL\n\n\ncommand -- --interactive\n\n\nEnters interactive mode.\n\n\n\n\n\n\nSeparator\n\n\ncommand -- --separator=X\n\n\nThis sets the separator to \nX\n. The default separator is \n-\n.\n\n\n\n\n\n\nCompletion\n\n\ncommand -- --completion\n\n\nGenerate a completion script for the CLI.\n\n\n\n\n\n\nTrace\n\n\ncommand -- --trace\n\n\nGets a Fire trace for the command.\n\n\n\n\n\n\nVerbose\n\n\ncommand -- --verbose\n\n\n\n\n\n\n\n\n\n\nNote that flags are separated from the Fire command by an isolated \n--\n arg.\n\n\nDisclaimer\n\n\nThis is not an official Google product.", 
            "title": "Overview"
        }, 
        {
            "location": "/#python-fire", 
            "text": "Python Fire is a library for automatically generating command line interfaces\n(CLIs) from absolutely any Python object.   Python Fire is a simple way to create a CLI in Python.  [1]  Python Fire is a helpful tool for developing and debugging Python code.  [2]  Python Fire helps with exploring existing code or turning other people's code\ninto a CLI.  [3]  Python Fire makes transitioning between Bash and Python easier.  [4]  Python Fire makes using a Python REPL easier by setting up the REPL with the\nmodules and variables you'll need already imported and created.  [5]", 
            "title": "Python Fire"
        }, 
        {
            "location": "/#installation", 
            "text": "To install Python Fire with pip, run:  pip install fire  To install Python Fire with conda, run:  conda install fire -c conda-forge  To install Python Fire from source, first clone the repository and then run: python setup.py install", 
            "title": "Installation"
        }, 
        {
            "location": "/#basic-usage", 
            "text": "You can call  Fire  on any Python object: \nfunctions, classes, modules, objects, dictionaries, lists, tuples, etc.\nThey all work!  Here's an example of calling Fire on a class.  import fire\n\nclass Calculator(object):\n   A simple calculator class. \n\n  def double(self, number):\n    return 2 * number\n\nif __name__ == '__main__':\n  fire.Fire(Calculator)  Then, from the command line, you can run:  python calculator.py double 10  # 20\npython calculator.py double --number=15  # 30  To learn how Fire behaves on functions, objects, dicts, lists, etc, and to learn\nabout Fire's other features, see the  Using a Fire CLI page .  For additional examples, see  The Python Fire Guide .", 
            "title": "Basic Usage"
        }, 
        {
            "location": "/#why-is-it-called-fire", 
            "text": "When you call  Fire , it fires off (executes) your command.", 
            "title": "Why is it called Fire?"
        }, 
        {
            "location": "/#where-can-i-learn-more", 
            "text": "Please see  The Python Fire Guide .", 
            "title": "Where can I learn more?"
        }, 
        {
            "location": "/#reference", 
            "text": "Setup  Command  Notes      install  pip install fire         Creating a CLI  Command  Notes      import  import fire     Call  fire.Fire()  Turns the current module into a Fire CLI.    Call  fire.Fire(component)  Turns  component  into a Fire CLI.        Using a CLI  Command  Notes      Help  command -- --help     REPL  command -- --interactive  Enters interactive mode.    Separator  command -- --separator=X  This sets the separator to  X . The default separator is  - .    Completion  command -- --completion  Generate a completion script for the CLI.    Trace  command -- --trace  Gets a Fire trace for the command.    Verbose  command -- --verbose      Note that flags are separated from the Fire command by an isolated  --  arg.", 
            "title": "Reference"
        }, 
        {
            "location": "/#disclaimer", 
            "text": "This is not an official Google product.", 
            "title": "Disclaimer"
        }, 
        {
            "location": "/installation/", 
            "text": "Installation\n\n\nTo install Python Fire with pip, run: \npip install fire\n\n\nTo install Python Fire with conda, run: \nconda install fire -c conda-forge\n\n\nTo install Python Fire from source, first clone the repository and then run:\n\npython setup.py install", 
            "title": "Installation"
        }, 
        {
            "location": "/installation/#installation", 
            "text": "To install Python Fire with pip, run:  pip install fire  To install Python Fire with conda, run:  conda install fire -c conda-forge  To install Python Fire from source, first clone the repository and then run: python setup.py install", 
            "title": "Installation"
        }, 
        {
            "location": "/benefits/", 
            "text": "Benefits of Python Fire\n\n\n\n\nCreate CLIs in Python\n\n\nIt's dead simple. Simply write the functionality you want exposed at the command\nline as a function / module / class, and then call Fire. With this addition of a\nsingle-line call to Fire, your CLI is ready to go.\n\n\n\n\nDevelop and debug Python code\n\n\nWhen you're writing a Python library, you probably want to try it out as you go.\nYou could write a main method to check the functionality you're interested in,\nbut then you have to change the main method with every new experiment you're\ninterested in testing, and constantly updating the main method is a hassle.\nYou could also open an IPython REPL and import your library there and test it,\nbut then you have to deal with reloading your imports every time you change\nsomething.\n\n\nIf you simply call Fire in your library, then you can run all of it's\nfunctionality from the command line without having to keep making changes to\na main method. And if you use the \n--interactive\n flag to enter an IPython REPL\nthen you don't need to load the imports or create your variables; they'll\nalready be ready for use as soon as you start the REPL.\n\n\n\n\nExplore existing code; turn other people's code into a CLI\n\n\nYou can take an existing module, maybe even one that you don't have access to\nthe source code for, and call \nFire\n on it. This lets you easily see what\nfunctionality this code exposes, without you having to read through all the\ncode.\n\n\nThis technique can be a very simple way to create very powerful CLIs. Call\n\nFire\n on the difflib library and you get a powerful diffing tool. Call \nFire\n\non the Python Imaging Library (PIL) module and you get a powerful image\nmanipulation command line tool, very similar in nature to ImageMagick.\n\n\nThe auto-generated help strings that Fire provides when you run a Fire CLI\nallow you to see all the functionality these modules provide in a concise\nmanner.\n\n\n\n\nTransition between Bash and Python\n\n\nUsing Fire lets you call Python directly from Bash. So you can mix your Python\nfunctions with the unix tools you know and love, like \ngrep\n, \nxargs\n, \nwc\n,\netc.\n\n\nAdditionally since writing CLIs in Python requires only a single call to Fire,\nit is now easy to write even one-off scripts that would previously have been in\nBash, in Python.\n\n\n\n\nExplore code in a Python REPL\n\n\nWhen you use the \n--interactive\n flag to enter an IPython REPL, it starts with\nvariables and modules already defined for you. You don't need to waste time\nimporting the modules you care about or defining the variables you're going to\nuse, since Fire has already done so for you.", 
            "title": "Benefits"
        }, 
        {
            "location": "/benefits/#benefits-of-python-fire", 
            "text": "", 
            "title": "Benefits of Python Fire"
        }, 
        {
            "location": "/benefits/#create-clis-in-python", 
            "text": "It's dead simple. Simply write the functionality you want exposed at the command\nline as a function / module / class, and then call Fire. With this addition of a\nsingle-line call to Fire, your CLI is ready to go.", 
            "title": "Create CLIs in Python"
        }, 
        {
            "location": "/benefits/#develop-and-debug-python-code", 
            "text": "When you're writing a Python library, you probably want to try it out as you go.\nYou could write a main method to check the functionality you're interested in,\nbut then you have to change the main method with every new experiment you're\ninterested in testing, and constantly updating the main method is a hassle.\nYou could also open an IPython REPL and import your library there and test it,\nbut then you have to deal with reloading your imports every time you change\nsomething.  If you simply call Fire in your library, then you can run all of it's\nfunctionality from the command line without having to keep making changes to\na main method. And if you use the  --interactive  flag to enter an IPython REPL\nthen you don't need to load the imports or create your variables; they'll\nalready be ready for use as soon as you start the REPL.", 
            "title": "Develop and debug Python code"
        }, 
        {
            "location": "/benefits/#explore-existing-code-turn-other-peoples-code-into-a-cli", 
            "text": "You can take an existing module, maybe even one that you don't have access to\nthe source code for, and call  Fire  on it. This lets you easily see what\nfunctionality this code exposes, without you having to read through all the\ncode.  This technique can be a very simple way to create very powerful CLIs. Call Fire  on the difflib library and you get a powerful diffing tool. Call  Fire \non the Python Imaging Library (PIL) module and you get a powerful image\nmanipulation command line tool, very similar in nature to ImageMagick.  The auto-generated help strings that Fire provides when you run a Fire CLI\nallow you to see all the functionality these modules provide in a concise\nmanner.", 
            "title": "Explore existing code; turn other people's code into a CLI"
        }, 
        {
            "location": "/benefits/#transition-between-bash-and-python", 
            "text": "Using Fire lets you call Python directly from Bash. So you can mix your Python\nfunctions with the unix tools you know and love, like  grep ,  xargs ,  wc ,\netc.  Additionally since writing CLIs in Python requires only a single call to Fire,\nit is now easy to write even one-off scripts that would previously have been in\nBash, in Python.", 
            "title": "Transition between Bash and Python"
        }, 
        {
            "location": "/benefits/#explore-code-in-a-python-repl", 
            "text": "When you use the  --interactive  flag to enter an IPython REPL, it starts with\nvariables and modules already defined for you. You don't need to waste time\nimporting the modules you care about or defining the variables you're going to\nuse, since Fire has already done so for you.", 
            "title": "Explore code in a Python REPL"
        }, 
        {
            "location": "/guide/", 
            "text": "The Python Fire Guide\n\n\nIntroduction\n\n\nWelcome to the Python Fire guide! Python Fire is a Python library that will turn\nany Python component into a command line interface with just a single call to\n\nFire\n.\n\n\nLet's get started!\n\n\nInstallation\n\n\nTo install Python Fire from pypi, run:\n\n\npip install fire\n\n\nAlternatively, to install Python Fire from source, clone the source and run:\n\n\npython setup.py install\n\n\nHello World\n\n\nVersion 1: \nfire.Fire()\n\n\nThe easiest way to use Fire is to take any Python program, and then simply call\n\nfire.Fire()\n at the end of the program. This will expose the full contents of\nthe program to the command line.\n\n\nimport fire\n\ndef hello(name):\n  return 'Hello {name}!'.format(name=name)\n\nif __name__ == '__main__':\n  fire.Fire()\n\n\n\n\nHere's how we can run our program from the command line:\n\n\n$ python example.py hello World\nHello World!\n\n\n\n\nVersion 2: \nfire.Fire(\nfn\n)\n\n\nLet's modify our program slightly to only expose the \nhello\n function to the\ncommand line.\n\n\nimport fire\n\ndef hello(name):\n  return 'Hello {name}!'.format(name=name)\n\nif __name__ == '__main__':\n  fire.Fire(hello)\n\n\n\n\nHere's how we can run this from the command line:\n\n\n$ python example.py World\nHello World!\n\n\n\n\nNotice we no longer have to specify to run the \nhello\n function, because we\ncalled \nfire.Fire(hello)\n.\n\n\nVersion 3: Using a main\n\n\nWe can alternatively write this program like this:\n\n\nimport fire\n\ndef hello(name):\n  return 'Hello {name}!'.format(name=name)\n\ndef main():\n  fire.Fire(hello)\n\nif __name__ == '__main__':\n  main()\n\n\n\n\nOr if we're using\n\nentry points\n,\nthen simply this:\n\n\nimport fire\n\ndef hello(name):\n  return 'Hello {name}!'.format(name=name)\n\ndef main():\n  fire.Fire(hello)\n\n\n\n\nExposing Multiple Commands\n\n\nIn the previous example, we exposed a single function to the command line. Now\nwe'll look at ways of exposing multiple functions to the command line.\n\n\nVersion 1: \nfire.Fire()\n\n\nThe simplest way to expose multiple commands is to write multiple functions, and\nthen call Fire.\n\n\nimport fire\n\ndef add(x, y):\n  return x + y\n\ndef multiply(x, y):\n  return x * y\n\nif __name__ == '__main__':\n  fire.Fire()\n\n\n\n\nWe can use this like so:\n\n\n$ python example.py add 10 20\n30\n$ python example.py multiply 10 20\n200\n\n\n\n\nYou'll notice that Fire correctly parsed \n10\n and \n20\n as numbers, rather than\nas strings. Read more about \nargument parsing here\n.\n\n\nVersion 2: \nfire.Fire(\ndict\n)\n\n\nIn version 1 we exposed all the program's functionality to the command line. By\nusing a dict, we can selectively expose functions to the command line.\n\n\nimport fire\n\ndef add(x, y):\n  return x + y\n\ndef multiply(x, y):\n  return x * y\n\nif __name__ == '__main__':\n  fire.Fire({\n      'add': add,\n      'multiply': multiply,\n  })\n\n\n\n\nWe can use this in the same way as before:\n\n\n$ python example.py add 10 20\n30\n$ python example.py multiply 10 20\n200\n\n\n\n\nVersion 3: \nfire.Fire(\nobject\n)\n\n\nFire also works on objects, as in this variant. This is a good way to expose\nmultiple commands.\n\n\nimport fire\n\nclass Calculator(object):\n\n  def add(self, x, y):\n    return x + y\n\n  def multiply(self, x, y):\n    return x * y\n\nif __name__ == '__main__':\n  calculator = Calculator()\n  fire.Fire(calculator)\n\n\n\n\nWe can use this in the same way as before:\n\n\n$ python example.py add 10 20\n30\n$ python example.py multiply 10 20\n200\n\n\n\n\nVersion 4: \nfire.Fire(\nclass\n)\n\n\nFire also works on classes. This is another good way to expose multiple\ncommands.\n\n\nimport fire\n\nclass Calculator(object):\n\n  def add(self, x, y):\n    return x + y\n\n  def multiply(self, x, y):\n    return x * y\n\nif __name__ == '__main__':\n  fire.Fire(Calculator)\n\n\n\n\nWe can use this in the same way as before:\n\n\n$ python example.py add 10 20\n30\n$ python example.py multiply 10 20\n200\n\n\n\n\nWhy might you prefer a class over an object? One reason is that you can pass\narguments for constructing the class too, as in this broken calculator example.\n\n\nimport fire\n\nclass BrokenCalculator(object):\n\n  def __init__(self, offset=1):\n      self._offset = offset\n\n  def add(self, x, y):\n    return x + y + self._offset\n\n  def multiply(self, x, y):\n    return x * y + self._offset\n\nif __name__ == '__main__':\n  fire.Fire(BrokenCalculator)\n\n\n\n\nWhen you use a broken calculator, you get wrong answers:\n\n\n$ python example.py add 10 20\n31\n$ python example.py multiply 10 20\n201\n\n\n\n\nBut you can always fix it:\n\n\n$ python example.py add 10 20 --offset=0\n30\n$ python example.py multiply 10 20 --offset=0\n200\n\n\n\n\nUnlike calling ordinary functions, which can be done both with positional\narguments and named arguments (--flag syntax), arguments to __init__\nfunctions must be passed with the --flag syntax. See the section on\n\ncalling functions\n for more.\n\n\nGrouping Commands\n\n\nHere's an example of how you might make a command line interface with grouped\ncommands.\n\n\nclass IngestionStage(object):\n\n  def run(self):\n    return 'Ingesting! Nom nom nom...'\n\nclass DigestionStage(object):\n\n  def run(self, volume=1):\n    return ' '.join(['Burp!'] * volume)\n\n  def status(self):\n    return 'Satiated.'\n\nclass Pipeline(object):\n\n  def __init__(self):\n    self.ingestion = IngestionStage()\n    self.digestion = DigestionStage()\n\n  def run(self):\n    self.ingestion.run()\n    self.digestion.run()\n\nif __name__ == '__main__':\n  fire.Fire(Pipeline)\n\n\n\n\nHere's how this looks at the command line:\n\n\n$ python example.py run\nIngesting! Nom nom nom...\nBurp!\n$ python example.py ingestion run\nIngesting! Nom nom nom...\n$ python example.py digestion run\nBurp!\n$ python example.py digestion status\nSatiated.\n\n\n\n\nYou can nest your commands in arbitrarily complex ways, if you're feeling grumpy\nor adventurous.\n\n\nAccessing Properties\n\n\nIn the examples we've looked at so far, our invocations of \npython example.py\n\nhave all run some function from the example program. In this example, we simply\naccess a property.\n\n\nfrom airports import airports\n\nimport fire\n\nclass Airport(object):\n\n  def __init__(self, code):\n    self.code = code\n    self.name = dict(airports).get(self.code)\n    self.city = self.name.split(',')[0] if self.name else None\n\nif __name__ == '__main__':\n  fire.Fire(Airport)\n\n\n\n\nNow we can use this program to learn about airport codes!\n\n\n$ python example.py --code=JFK code\nJFK\n$ python example.py --code=SJC name\nSan Jose-Sunnyvale-Santa Clara, CA - Norman Y. Mineta San Jose International (SJC)\n$ python example.py --code=ALB city\nAlbany-Schenectady-Troy\n\n\n\n\nBy the way, you can find this\n\nairports module here\n.\n\n\nChaining Function Calls\n\n\nWhen you run a Fire CLI, you can take all the same actions on the \nresult\n of\nthe call to Fire that you can take on the original object passed in.\n\n\nFor example, we can use our Airport CLI from the previous example like this:\n\n\n$ python example.py --code=ALB city upper\nALBANY-SCHENECTADY-TROY\n\n\n\n\nThis works since \nupper\n is a method on all strings.\n\n\nSo, if you want to set up your functions to chain nicely, all you have to do is\nhave a class whose methods return self. Here's an example.\n\n\nimport fire\n\nclass BinaryCanvas(object):\n  \nA canvas with which to make binary art, one bit at a time.\n\n\n  def __init__(self, size=10):\n    self.pixels = [[0] * size for _ in range(size)]\n    self._size = size\n    self._row = 0  # The row of the cursor.\n    self._col = 0  # The column of the cursor.\n\n  def __str__(self):\n    return '\\n'.join(' '.join(str(pixel) for pixel in row) for row in self.pixels)\n\n  def show(self):\n    print(self)\n    return self\n\n  def move(self, row, col):\n    self._row = row % self._size\n    self._col = col % self._size\n    return self\n\n  def on(self):\n    return self.set(1)\n\n  def off(self):\n    return self.set(0)\n\n  def set(self, value):\n    self.pixels[self._row][self._col] = value\n    return self\n\nif __name__ == '__main__':\n  fire.Fire(BinaryCanvas)\n\n\n\n\nNow we can draw stuff :).\n\n\n$ python example.py move 3 3 on move 3 6 on move 6 3 on move 6 6 on move 7 4 on move 7 5 on __str__\n0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0\n0 0 0 1 0 0 1 0 0 0\n0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0\n0 0 0 1 0 0 1 0 0 0\n0 0 0 0 1 1 0 0 0 0\n0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0\n\n\n\n\nIt's supposed to be a smiley face.\n\n\nCan we make an even simpler example than Hello World?\n\n\nYes, this program is even simpler than our original Hello World example.\n\n\nimport fire\nenglish = 'Hello World'\nspanish = 'Hola Mundo'\nfire.Fire()\n\n\n\n\nYou can use it like this:\n\n\n$ python example.py english\nHello World\n$ python example.py spanish\nHola Mundo\n\n\n\n\nCalling Functions\n\n\nArguments to a constructor are passed by name using flag syntax \n--name=value\n.\n\n\nFor example, consider this simple class:\n\n\nimport fire\n\nclass Building(object):\n\n  def __init__(self, name, stories=1):\n    self.name = name\n    self.stories = 1\n\n  def climb_stairs(self, stairs_per_story=10):\n    for story in range(self.stories):\n      for stair in range(1, stairs_per_story):\n        yield stair\n        yield 'Phew!'\n    yield 'Done!'\n\nif __name__ == '__main__':\n  fire.Fire(Building)\n\n\n\n\nWe can instantiate it as follows: \npython example.py --name=\"Sherrerd Hall\"\n\n\nArguments to other functions may be passed positionally or by name using flag\nsyntax.\n\n\nTo instantiate a \nBuilding\n and then run the \nclimb_stairs\n function, the\nfollowing commands are all valid:\n\n\n$ python example.py --name=\nSherrerd Hall\n --stories=3 climb_stairs 10\n$ python example.py --name=\nSherrerd Hall\n climb_stairs --stairs_per_story=10\n$ python example.py --name=\nSherrerd Hall\n climb_stairs --stairs-per-story 10\n$ python example.py climb-stairs --stairs-per-story 10 --name=\nSherrerd Hall\n\n\n\n\n\nYou'll notice that hyphens and underscores (\n-\n and \n_\n) are interchangeable in\nmember names and flag names.\n\n\nYou'll also notice that the constructor's arguments can come after the\nfunction's arguments or before the function.\n\n\nYou'll also notice that the equal sign between the flag name and its value is\noptional.\n\n\nFunctions with \n*varargs\n and \n**kwargs\n\n\nFire supports functions that take *varargs or **kwargs. Here's an example:\n\n\nimport fire\n\ndef order_by_length(*items):\n  \nOrders items by length, breaking ties alphabetically.\n\n  sorted_items = sorted(items, key=lambda item: (len(str(item)), str(item)))\n  return ' '.join(sorted_items)\n\nif __name__ == '__main__':\n  fire.Fire(order_by_length)\n\n\n\n\nTo use it, we run:\n\n\n$ python example.py dog cat elephant\ncat dog elephant\n\n\n\n\nYou can use a separator to indicate that you're done providing arguments to a\nfunction. All arguments after the separator will be used to process the result\nof the function, rather than being passed to the function itself. The default\nseparator is the hyphen \n-\n.\n\n\nHere's an example where we use a separator.\n\n\n$ python example.py dog cat elephant - upper\nCAT DOG ELEPHANT\n\n\n\n\nWithout the separator, upper would have been treated as another argument.\n\n\n$ python example.py dog cat elephant upper\ncat dog upper elephant\n\n\n\n\nYou can change the separator with the \n--separator\n flag. Flags are always\nseparated from your Fire command by an isolated \n--\n. Here's an example where we\nchange the separator.\n\n\n$ python example.py dog cat elephant X upper -- --separator=X\nCAT DOG ELEPHANT\n\n\n\n\nSeparators can be useful when a function accepts *varargs, **kwargs, or\ndefault values that you don't want to specify. It is also important to remember\nto change the separator if you want to pass \n-\n as an argument.\n\n\nArgument Parsing\n\n\nThe types of the arguments are determined by their values, rather than by the\nfunction signature where they're used. You can pass any Python literal from the\ncommand line: numbers, strings, tuples, lists, dictionaries, (sets are only\nsupported in some versions of Python). You can also nest the collections\narbitrarily as long as they only contain literals.\n\n\nTo demonstrate this, we'll make a small example program that tells us the type\nof any argument we give it:\n\n\nimport fire\nfire.Fire(lambda obj: type(obj).__name__)\n\n\n\n\nAnd we'll use it like so:\n\n\n$ python example.py 10\nint\n$ python example.py 10.0\nfloat\n$ python example.py hello\nstr\n$ python example.py '(1,2)'\ntuple\n$ python example.py [1,2]\nlist\n$ python example.py True\nbool\n$ python example.py {name: David}\ndict\n\n\n\n\nYou'll notice in that last example that bare-words are automatically replaced\nwith strings.\n\n\nBe careful with your quotes! If you want to pass the string \n\"10\"\n, rather than\nthe int \n10\n, you'll need to either escape or quote your quotes. Otherwise Bash\nwill eat your quotes and pass an unquoted \n10\n to your Python program, where\nFire will interpret it as a number.\n\n\n$ python example.py 10\nint\n$ python example.py \n10\n\nint\n$ python example.py '\n10\n'\nstr\n$ python example.py \n'10'\n\nstr\n$ python example.py \\\n10\\\n\nstr\n\n\n\n\nBe careful with your quotes! Remember that Bash processes your arguments first,\nand then Fire parses the result of that.\nIf you wanted to pass the dict \n{\"name\": \"David Bieber\"}\n to your program, you\nmight try this:\n\n\n$ python example.py '{\nname\n: \nDavid Bieber\n}'  # Good! Do this.\ndict\n$ python example.py {\nname\n:'\nDavid Bieber\n'}  # Okay.\ndict\n$ python example.py {\nname\n:\nDavid Bieber\n}  # Wrong. This is parsed as a string.\nstr\n$ python example.py {\nname\n: \nDavid Bieber\n}  # Wrong. This isn't even treated as a single argument.\n\nerror\n\n$ python example.py '{\nname\n: \nJustin Bieber\n}'  # Wrong. This is not the Bieber you're looking for. (The syntax is fine though :))\ndict\n\n\n\n\nBoolean Arguments\n\n\nThe tokens \nTrue\n and \nFalse\n are parsed as boolean values.\n\n\nYou may also specify booleans via flag syntax \n--name\n and \n--noname\n, which set\n\nname\n to \nTrue\n and \nFalse\n respectively.\n\n\nContinuing the previous example, we could run any of the following:\n\n\n$ python example.py --obj=True\nbool\n$ python example.py --obj=False\nbool\n$ python example.py --obj\nbool\n$ python example.py --noobj\nbool\n\n\n\n\nBe careful with boolean flags! If a token other than another flag immediately\nfollows a flag that's supposed to be a boolean, the flag will take on the value\nof the token rather than the boolean value. You can resolve this: by putting a\nseparator after your last flag, by explicitly stating the value of the boolean\nflag (as in \n--obj=True\n), or by making sure there's another flag after any\nboolean flag argument.\n\n\nUsing Fire Flags\n\n\nFire CLIs all come with a number of flags. These flags should be separated from\nthe Fire command by an isolated \n--\n. If there is at least one isolated \n--\n\nargument, then arguments after the final isolated \n--\n are treated as flags,\nwhereas all arguments before the final isolated \n--\n are considered part of the\nFire command.\n\n\nOne useful flag is the \n--interactive\n flag. Use the \n--interactive\n flag on any\nCLI to enter a Python REPL with all the modules and variables used in the\ncontext where \nFire\n was called already available to you for use. Other useful\nvariables, such as the result of the Fire command will also be available. Use\nthis feature like this: \npython example.py -- --interactive\n.\n\n\nYou can add the help flag to any command to see help and usage information. Fire\nincorporates your docstrings into the help and usage information that it\ngenerates. Fire will try to provide help even if you omit the isolated \n--\n\nseparating the flags from the Fire command, but may not always be able to, since\n\nhelp\n is a valid argument name. Use this feature like this:\n\npython example.py -- --help\n.\n\n\nThe complete set of flags available is shown below, in the reference section.\n\n\nReference\n\n\n\n\n\n\n\n\nSetup\n\n\nCommand\n\n\nNotes\n\n\n\n\n\n\n\n\n\n\ninstall\n\n\npip install fire\n\n\n\n\n\n\n\n\n\n\nCreating a CLI\n\n\n\n\n\n\n\n\nCreating a CLI\n\n\nCommand\n\n\nNotes\n\n\n\n\n\n\n\n\n\n\nimport\n\n\nimport fire\n\n\n\n\n\n\n\n\nCall\n\n\nfire.Fire()\n\n\nTurns the current module into a Fire CLI.\n\n\n\n\n\n\nCall\n\n\nfire.Fire(component)\n\n\nTurns \ncomponent\n into a Fire CLI.\n\n\n\n\n\n\n\n\nFlags\n\n\n\n\n\n\n\n\nUsing a CLI\n\n\nCommand\n\n\nNotes\n\n\n\n\n\n\n\n\n\n\nHelp\n\n\ncommand -- --help\n\n\nShow help and usage information for the command.\n\n\n\n\n\n\nREPL\n\n\ncommand -- --interactive\n\n\nEnter interactive mode.\n\n\n\n\n\n\nSeparator\n\n\ncommand -- --separator=X\n\n\nThis sets the separator to \nX\n. The default separator is \n-\n.\n\n\n\n\n\n\nCompletion\n\n\ncommand -- --completion\n\n\nGenerate a completion script for the CLI.\n\n\n\n\n\n\nTrace\n\n\ncommand -- --trace\n\n\nGets a Fire trace for the command.\n\n\n\n\n\n\nVerbose\n\n\ncommand -- --verbose\n\n\nInclude private members in the output.\n\n\n\n\n\n\n\n\nNote that flags are separated from the Fire command by an isolated \n--\n arg.\n\n\nDisclaimer\n\n\nPython Fire is not an official Google product.", 
            "title": "The Python Fire Guide"
        }, 
        {
            "location": "/guide/#the-python-fire-guide", 
            "text": "", 
            "title": "The Python Fire Guide"
        }, 
        {
            "location": "/guide/#introduction", 
            "text": "Welcome to the Python Fire guide! Python Fire is a Python library that will turn\nany Python component into a command line interface with just a single call to Fire .  Let's get started!", 
            "title": "Introduction"
        }, 
        {
            "location": "/guide/#installation", 
            "text": "To install Python Fire from pypi, run:  pip install fire  Alternatively, to install Python Fire from source, clone the source and run:  python setup.py install", 
            "title": "Installation"
        }, 
        {
            "location": "/guide/#hello-world", 
            "text": "", 
            "title": "Hello World"
        }, 
        {
            "location": "/guide/#version-1-firefire", 
            "text": "The easiest way to use Fire is to take any Python program, and then simply call fire.Fire()  at the end of the program. This will expose the full contents of\nthe program to the command line.  import fire\n\ndef hello(name):\n  return 'Hello {name}!'.format(name=name)\n\nif __name__ == '__main__':\n  fire.Fire()  Here's how we can run our program from the command line:  $ python example.py hello World\nHello World!", 
            "title": "Version 1: fire.Fire()"
        }, 
        {
            "location": "/guide/#version-2-firefirefn", 
            "text": "Let's modify our program slightly to only expose the  hello  function to the\ncommand line.  import fire\n\ndef hello(name):\n  return 'Hello {name}!'.format(name=name)\n\nif __name__ == '__main__':\n  fire.Fire(hello)  Here's how we can run this from the command line:  $ python example.py World\nHello World!  Notice we no longer have to specify to run the  hello  function, because we\ncalled  fire.Fire(hello) .", 
            "title": "Version 2: fire.Fire(&lt;fn&gt;)"
        }, 
        {
            "location": "/guide/#version-3-using-a-main", 
            "text": "We can alternatively write this program like this:  import fire\n\ndef hello(name):\n  return 'Hello {name}!'.format(name=name)\n\ndef main():\n  fire.Fire(hello)\n\nif __name__ == '__main__':\n  main()  Or if we're using entry points ,\nthen simply this:  import fire\n\ndef hello(name):\n  return 'Hello {name}!'.format(name=name)\n\ndef main():\n  fire.Fire(hello)", 
            "title": "Version 3: Using a main"
        }, 
        {
            "location": "/guide/#exposing-multiple-commands", 
            "text": "In the previous example, we exposed a single function to the command line. Now\nwe'll look at ways of exposing multiple functions to the command line.", 
            "title": "Exposing Multiple Commands"
        }, 
        {
            "location": "/guide/#version-1-firefire_1", 
            "text": "The simplest way to expose multiple commands is to write multiple functions, and\nthen call Fire.  import fire\n\ndef add(x, y):\n  return x + y\n\ndef multiply(x, y):\n  return x * y\n\nif __name__ == '__main__':\n  fire.Fire()  We can use this like so:  $ python example.py add 10 20\n30\n$ python example.py multiply 10 20\n200  You'll notice that Fire correctly parsed  10  and  20  as numbers, rather than\nas strings. Read more about  argument parsing here .", 
            "title": "Version 1: fire.Fire()"
        }, 
        {
            "location": "/guide/#version-2-firefiredict", 
            "text": "In version 1 we exposed all the program's functionality to the command line. By\nusing a dict, we can selectively expose functions to the command line.  import fire\n\ndef add(x, y):\n  return x + y\n\ndef multiply(x, y):\n  return x * y\n\nif __name__ == '__main__':\n  fire.Fire({\n      'add': add,\n      'multiply': multiply,\n  })  We can use this in the same way as before:  $ python example.py add 10 20\n30\n$ python example.py multiply 10 20\n200", 
            "title": "Version 2: fire.Fire(&lt;dict&gt;)"
        }, 
        {
            "location": "/guide/#version-3-firefireobject", 
            "text": "Fire also works on objects, as in this variant. This is a good way to expose\nmultiple commands.  import fire\n\nclass Calculator(object):\n\n  def add(self, x, y):\n    return x + y\n\n  def multiply(self, x, y):\n    return x * y\n\nif __name__ == '__main__':\n  calculator = Calculator()\n  fire.Fire(calculator)  We can use this in the same way as before:  $ python example.py add 10 20\n30\n$ python example.py multiply 10 20\n200", 
            "title": "Version 3: fire.Fire(&lt;object&gt;)"
        }, 
        {
            "location": "/guide/#version-4-firefireclass", 
            "text": "Fire also works on classes. This is another good way to expose multiple\ncommands.  import fire\n\nclass Calculator(object):\n\n  def add(self, x, y):\n    return x + y\n\n  def multiply(self, x, y):\n    return x * y\n\nif __name__ == '__main__':\n  fire.Fire(Calculator)  We can use this in the same way as before:  $ python example.py add 10 20\n30\n$ python example.py multiply 10 20\n200  Why might you prefer a class over an object? One reason is that you can pass\narguments for constructing the class too, as in this broken calculator example.  import fire\n\nclass BrokenCalculator(object):\n\n  def __init__(self, offset=1):\n      self._offset = offset\n\n  def add(self, x, y):\n    return x + y + self._offset\n\n  def multiply(self, x, y):\n    return x * y + self._offset\n\nif __name__ == '__main__':\n  fire.Fire(BrokenCalculator)  When you use a broken calculator, you get wrong answers:  $ python example.py add 10 20\n31\n$ python example.py multiply 10 20\n201  But you can always fix it:  $ python example.py add 10 20 --offset=0\n30\n$ python example.py multiply 10 20 --offset=0\n200  Unlike calling ordinary functions, which can be done both with positional\narguments and named arguments (--flag syntax), arguments to __init__\nfunctions must be passed with the --flag syntax. See the section on calling functions  for more.", 
            "title": "Version 4: fire.Fire(&lt;class&gt;)"
        }, 
        {
            "location": "/guide/#grouping-commands", 
            "text": "Here's an example of how you might make a command line interface with grouped\ncommands.  class IngestionStage(object):\n\n  def run(self):\n    return 'Ingesting! Nom nom nom...'\n\nclass DigestionStage(object):\n\n  def run(self, volume=1):\n    return ' '.join(['Burp!'] * volume)\n\n  def status(self):\n    return 'Satiated.'\n\nclass Pipeline(object):\n\n  def __init__(self):\n    self.ingestion = IngestionStage()\n    self.digestion = DigestionStage()\n\n  def run(self):\n    self.ingestion.run()\n    self.digestion.run()\n\nif __name__ == '__main__':\n  fire.Fire(Pipeline)  Here's how this looks at the command line:  $ python example.py run\nIngesting! Nom nom nom...\nBurp!\n$ python example.py ingestion run\nIngesting! Nom nom nom...\n$ python example.py digestion run\nBurp!\n$ python example.py digestion status\nSatiated.  You can nest your commands in arbitrarily complex ways, if you're feeling grumpy\nor adventurous.", 
            "title": "Grouping Commands"
        }, 
        {
            "location": "/guide/#accessing-properties", 
            "text": "In the examples we've looked at so far, our invocations of  python example.py \nhave all run some function from the example program. In this example, we simply\naccess a property.  from airports import airports\n\nimport fire\n\nclass Airport(object):\n\n  def __init__(self, code):\n    self.code = code\n    self.name = dict(airports).get(self.code)\n    self.city = self.name.split(',')[0] if self.name else None\n\nif __name__ == '__main__':\n  fire.Fire(Airport)  Now we can use this program to learn about airport codes!  $ python example.py --code=JFK code\nJFK\n$ python example.py --code=SJC name\nSan Jose-Sunnyvale-Santa Clara, CA - Norman Y. Mineta San Jose International (SJC)\n$ python example.py --code=ALB city\nAlbany-Schenectady-Troy  By the way, you can find this airports module here .", 
            "title": "Accessing Properties"
        }, 
        {
            "location": "/guide/#chaining-function-calls", 
            "text": "When you run a Fire CLI, you can take all the same actions on the  result  of\nthe call to Fire that you can take on the original object passed in.  For example, we can use our Airport CLI from the previous example like this:  $ python example.py --code=ALB city upper\nALBANY-SCHENECTADY-TROY  This works since  upper  is a method on all strings.  So, if you want to set up your functions to chain nicely, all you have to do is\nhave a class whose methods return self. Here's an example.  import fire\n\nclass BinaryCanvas(object):\n   A canvas with which to make binary art, one bit at a time. \n\n  def __init__(self, size=10):\n    self.pixels = [[0] * size for _ in range(size)]\n    self._size = size\n    self._row = 0  # The row of the cursor.\n    self._col = 0  # The column of the cursor.\n\n  def __str__(self):\n    return '\\n'.join(' '.join(str(pixel) for pixel in row) for row in self.pixels)\n\n  def show(self):\n    print(self)\n    return self\n\n  def move(self, row, col):\n    self._row = row % self._size\n    self._col = col % self._size\n    return self\n\n  def on(self):\n    return self.set(1)\n\n  def off(self):\n    return self.set(0)\n\n  def set(self, value):\n    self.pixels[self._row][self._col] = value\n    return self\n\nif __name__ == '__main__':\n  fire.Fire(BinaryCanvas)  Now we can draw stuff :).  $ python example.py move 3 3 on move 3 6 on move 6 3 on move 6 6 on move 7 4 on move 7 5 on __str__\n0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0\n0 0 0 1 0 0 1 0 0 0\n0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0\n0 0 0 1 0 0 1 0 0 0\n0 0 0 0 1 1 0 0 0 0\n0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0  It's supposed to be a smiley face.", 
            "title": "Chaining Function Calls"
        }, 
        {
            "location": "/guide/#can-we-make-an-even-simpler-example-than-hello-world", 
            "text": "Yes, this program is even simpler than our original Hello World example.  import fire\nenglish = 'Hello World'\nspanish = 'Hola Mundo'\nfire.Fire()  You can use it like this:  $ python example.py english\nHello World\n$ python example.py spanish\nHola Mundo", 
            "title": "Can we make an even simpler example than Hello World?"
        }, 
        {
            "location": "/guide/#calling-functions", 
            "text": "Arguments to a constructor are passed by name using flag syntax  --name=value .  For example, consider this simple class:  import fire\n\nclass Building(object):\n\n  def __init__(self, name, stories=1):\n    self.name = name\n    self.stories = 1\n\n  def climb_stairs(self, stairs_per_story=10):\n    for story in range(self.stories):\n      for stair in range(1, stairs_per_story):\n        yield stair\n        yield 'Phew!'\n    yield 'Done!'\n\nif __name__ == '__main__':\n  fire.Fire(Building)  We can instantiate it as follows:  python example.py --name=\"Sherrerd Hall\"  Arguments to other functions may be passed positionally or by name using flag\nsyntax.  To instantiate a  Building  and then run the  climb_stairs  function, the\nfollowing commands are all valid:  $ python example.py --name= Sherrerd Hall  --stories=3 climb_stairs 10\n$ python example.py --name= Sherrerd Hall  climb_stairs --stairs_per_story=10\n$ python example.py --name= Sherrerd Hall  climb_stairs --stairs-per-story 10\n$ python example.py climb-stairs --stairs-per-story 10 --name= Sherrerd Hall   You'll notice that hyphens and underscores ( -  and  _ ) are interchangeable in\nmember names and flag names.  You'll also notice that the constructor's arguments can come after the\nfunction's arguments or before the function.  You'll also notice that the equal sign between the flag name and its value is\noptional.", 
            "title": "Calling Functions"
        }, 
        {
            "location": "/guide/#functions-with-varargs-and-kwargs", 
            "text": "Fire supports functions that take *varargs or **kwargs. Here's an example:  import fire\n\ndef order_by_length(*items):\n   Orders items by length, breaking ties alphabetically. \n  sorted_items = sorted(items, key=lambda item: (len(str(item)), str(item)))\n  return ' '.join(sorted_items)\n\nif __name__ == '__main__':\n  fire.Fire(order_by_length)  To use it, we run:  $ python example.py dog cat elephant\ncat dog elephant  You can use a separator to indicate that you're done providing arguments to a\nfunction. All arguments after the separator will be used to process the result\nof the function, rather than being passed to the function itself. The default\nseparator is the hyphen  - .  Here's an example where we use a separator.  $ python example.py dog cat elephant - upper\nCAT DOG ELEPHANT  Without the separator, upper would have been treated as another argument.  $ python example.py dog cat elephant upper\ncat dog upper elephant  You can change the separator with the  --separator  flag. Flags are always\nseparated from your Fire command by an isolated  -- . Here's an example where we\nchange the separator.  $ python example.py dog cat elephant X upper -- --separator=X\nCAT DOG ELEPHANT  Separators can be useful when a function accepts *varargs, **kwargs, or\ndefault values that you don't want to specify. It is also important to remember\nto change the separator if you want to pass  -  as an argument.", 
            "title": "Functions with *varargs and **kwargs"
        }, 
        {
            "location": "/guide/#argument-parsing", 
            "text": "The types of the arguments are determined by their values, rather than by the\nfunction signature where they're used. You can pass any Python literal from the\ncommand line: numbers, strings, tuples, lists, dictionaries, (sets are only\nsupported in some versions of Python). You can also nest the collections\narbitrarily as long as they only contain literals.  To demonstrate this, we'll make a small example program that tells us the type\nof any argument we give it:  import fire\nfire.Fire(lambda obj: type(obj).__name__)  And we'll use it like so:  $ python example.py 10\nint\n$ python example.py 10.0\nfloat\n$ python example.py hello\nstr\n$ python example.py '(1,2)'\ntuple\n$ python example.py [1,2]\nlist\n$ python example.py True\nbool\n$ python example.py {name: David}\ndict  You'll notice in that last example that bare-words are automatically replaced\nwith strings.  Be careful with your quotes! If you want to pass the string  \"10\" , rather than\nthe int  10 , you'll need to either escape or quote your quotes. Otherwise Bash\nwill eat your quotes and pass an unquoted  10  to your Python program, where\nFire will interpret it as a number.  $ python example.py 10\nint\n$ python example.py  10 \nint\n$ python example.py ' 10 '\nstr\n$ python example.py  '10' \nstr\n$ python example.py \\ 10\\ \nstr  Be careful with your quotes! Remember that Bash processes your arguments first,\nand then Fire parses the result of that.\nIf you wanted to pass the dict  {\"name\": \"David Bieber\"}  to your program, you\nmight try this:  $ python example.py '{ name :  David Bieber }'  # Good! Do this.\ndict\n$ python example.py { name :' David Bieber '}  # Okay.\ndict\n$ python example.py { name : David Bieber }  # Wrong. This is parsed as a string.\nstr\n$ python example.py { name :  David Bieber }  # Wrong. This isn't even treated as a single argument. error \n$ python example.py '{ name :  Justin Bieber }'  # Wrong. This is not the Bieber you're looking for. (The syntax is fine though :))\ndict", 
            "title": "Argument Parsing"
        }, 
        {
            "location": "/guide/#boolean-arguments", 
            "text": "The tokens  True  and  False  are parsed as boolean values.  You may also specify booleans via flag syntax  --name  and  --noname , which set name  to  True  and  False  respectively.  Continuing the previous example, we could run any of the following:  $ python example.py --obj=True\nbool\n$ python example.py --obj=False\nbool\n$ python example.py --obj\nbool\n$ python example.py --noobj\nbool  Be careful with boolean flags! If a token other than another flag immediately\nfollows a flag that's supposed to be a boolean, the flag will take on the value\nof the token rather than the boolean value. You can resolve this: by putting a\nseparator after your last flag, by explicitly stating the value of the boolean\nflag (as in  --obj=True ), or by making sure there's another flag after any\nboolean flag argument.", 
            "title": "Boolean Arguments"
        }, 
        {
            "location": "/guide/#using-fire-flags", 
            "text": "Fire CLIs all come with a number of flags. These flags should be separated from\nthe Fire command by an isolated  -- . If there is at least one isolated  -- \nargument, then arguments after the final isolated  --  are treated as flags,\nwhereas all arguments before the final isolated  --  are considered part of the\nFire command.  One useful flag is the  --interactive  flag. Use the  --interactive  flag on any\nCLI to enter a Python REPL with all the modules and variables used in the\ncontext where  Fire  was called already available to you for use. Other useful\nvariables, such as the result of the Fire command will also be available. Use\nthis feature like this:  python example.py -- --interactive .  You can add the help flag to any command to see help and usage information. Fire\nincorporates your docstrings into the help and usage information that it\ngenerates. Fire will try to provide help even if you omit the isolated  -- \nseparating the flags from the Fire command, but may not always be able to, since help  is a valid argument name. Use this feature like this: python example.py -- --help .  The complete set of flags available is shown below, in the reference section.", 
            "title": "Using Fire Flags"
        }, 
        {
            "location": "/guide/#reference", 
            "text": "Setup  Command  Notes      install  pip install fire", 
            "title": "Reference"
        }, 
        {
            "location": "/guide/#creating-a-cli", 
            "text": "Creating a CLI  Command  Notes      import  import fire     Call  fire.Fire()  Turns the current module into a Fire CLI.    Call  fire.Fire(component)  Turns  component  into a Fire CLI.", 
            "title": "Creating a CLI"
        }, 
        {
            "location": "/guide/#flags", 
            "text": "Using a CLI  Command  Notes      Help  command -- --help  Show help and usage information for the command.    REPL  command -- --interactive  Enter interactive mode.    Separator  command -- --separator=X  This sets the separator to  X . The default separator is  - .    Completion  command -- --completion  Generate a completion script for the CLI.    Trace  command -- --trace  Gets a Fire trace for the command.    Verbose  command -- --verbose  Include private members in the output.     Note that flags are separated from the Fire command by an isolated  --  arg.", 
            "title": "Flags"
        }, 
        {
            "location": "/guide/#disclaimer", 
            "text": "Python Fire is not an official Google product.", 
            "title": "Disclaimer"
        }, 
        {
            "location": "/using-cli/", 
            "text": "Using a Fire CLI\n\n\nBasic usage\n\n\nEvery Fire command corresponds to a Python component.\n\n\nThe simplest Fire command consists of running your program with no additional\narguments. This command corresponds to the Python component you called the\n\nFire\n function on. If you did not supply an object in the call to \nFire\n, then\nthe context in which \nFire\n was called will be used as the Python component.\n\n\nYou can append \n-- --help\n to any command to see what Python component it\ncorresponds to, as well as the various ways in which you can extend the command.\nFlags are always separated from the Fire command by an isolated \n--\n in order\nto distinguish between flags and named arguments.\n\n\nGiven a Fire command that corresponds to a Python object, you can extend that\ncommand to access a member of that object, call it with arguments if it is a\nfunction, instantiate it if it is a class, or index into it if it is a list.\n\n\nRead on to learn about how you can write a Fire command corresponding to\nwhatever Python component you're looking for.\n\n\nAccessing members of an object\n\n\nIf your command corresponds to an object, you can extend your command by adding\nthe name of a member of that object as a new argument to the command. The\nresulting command will correspond to that member.\n\n\nFor example, if the object your command corresponds to has a method defined on\nit named 'whack', then you can add the argument 'whack' to your command, and the\nresulting new command corresponds to the whack method.\n\n\nAs another example, if the object your command corresponds to has a property\nnamed high_score, then you can add the argument 'high-score' to your command,\nand the resulting new command corresponds to the value of the high_score\nproperty.\n\n\nAccessing members of a dict\n\n\nIf your command corresponds to a dict, you can extend your command by adding\nthe name of one of the dict's keys as an argument.\n\n\nFor example, \nwidget function-that-returns-dict key\n will correspond to the\nvalue of the item with key \nkey\n in the dict returned by\n\nfunction_that_returns_dict\n.\n\n\nAccessing members of a list or tuple\n\n\nIf your command corresponds to a list or tuple, you can extend your command by\nadding the index of an element of the component to your command as an argument.\n\n\nFor example, \nwidget function-that-returns-list 2\n will correspond to item 2 of\nthe result of function_that_returns_list.\n\n\nCalling a function\n\n\nIf your command corresponds to a function, you can extend your command by adding\nthe arguments of this function. Arguments can be specified positionally, or by\nname. To specify an argument by name, use flag syntax.\n\n\nFor example, suppose your \ncommand\n corresponds to the function \ndouble\n:\n\n\ndef double(value=0):\n  return 2 * value\n\n\n\n\nThen you can extend your command using named arguments as \ncommand --value 5\n,\nor using positional arguments as \ncommand 5\n. In both cases, the new command\ncorresponds to the result of the function, in this case the number 10.\n\n\nYou can force a function that takes a variable number of arguments to be\nevaluated by adding a separator (the default separator is the hyphen, \"-\"). This\nwill prevent arguments to the right of the separator from being consumed for\ncalling the function. This is useful if the function has arguments with default\nvalues, or if the function accepts *varargs, or if the function accepts\n**kwargs.\n\n\nSee also the section on \nChanging the Separator\n.\n\n\nInstantiating a class\n\n\nIf your command corresponds to a class, you can extend your command by adding\nthe arguments of the class's __init__ function. Arguments must be specified\nby name, using the flags syntax. See the section on\n\ncalling a function\n for more details.\n\n\nUsing Flags with Fire CLIs \n\n\nCommand line arguments to a Fire CLI are normally consumed by Fire, as described\nin the \nBasic Usage\n section. In order to set Flags, put the flags\nafter the final standalone \n--\n argument. (If there is no \n--\n argument, then no\narguments are used for flags.)\n\n\nFor example, to set the alsologtostderr flag, you could run the command:\n\nwidget bang --noise=boom -- --alsologtostderr\n. The --noise argument is\nconsumed by Fire, but the --alsologtostderr argument is treated as a normal\nFlag.\n\n\nAll CLIs built with Python Fire share some flags, as described in the next\nsections.\n\n\nPython Fire's Flags\n\n\nAs described in the \nUsing Flags\n section, you must add an\nisolated \n--\n argument in order to have arguments treated as Flags rather than\nbe consumed by Python Fire. All arguments to a Fire CLI after the final\nstandalone \n--\n argument are treated as Flags.\n\n\nThe following flags are accepted by all Fire CLIs:\n\n--interactive\n/\n-i\n,\n\n--help\n/\n-h\n,\n\n--separator\n,\n\n--completion\n,\n\n--trace\n,\nand \n--verbose\n/\n-v\n,\nas described in the following sections.\n\n\n--interactive\n: Interactive mode \n\n\nCall \nwidget -- --interactive\n or \nwidget -- -i\n to enter interactive mode. This\nwill put you in an IPython REPL, with the variable \nwidget\n already defined.\n\n\nYou can then explore the Python object that \nwidget\n corresponds to\ninteractively using Python.\n\n\n--completion\n: Generating a completion script \n\n\nCall \nwidget -- --completion\n to generate a completion script for the Fire CLI\n\nwidget\n. To save the completion script to your home directory, you could e.g.\nrun \nwidget -- --completion \n ~/.widget-completion\n. You should then source this\nfile; to get permanent completion, source this file from your .bashrc file.\n\n\nIf the commands available in the Fire CLI change, you'll have to regenerate the\ncompletion script and source it again.\n\n\n--help\n: Getting help \n\n\nLet say you have a command line tool named \nwidget\n that was made with Fire. How\ndo you use this Fire CLI?\n\n\nThe simplest way to get started is to run \nwidget -- --help\n. This will give you\nusage information for your CLI. You can always append \n-- --help\n to any Fire\ncommand in order to get usage information for that command and any subcommands.\n\n\nAdditionally, help will be displayed if you hit an error using Fire. For\nexample, if you try to pass too many or too few arguments to a function, then\nhelp will be displayed. Similarly, if you try to access a member that does not\nexist, or if you index into a list with too high an index, then help will be\ndisplayed.\n\n\nThe displayed help shows information about which Python component your command\ncorresponds to, as well as usage information for how to extend that command.\n\n\n--trace\n: Getting a Fire trace \n\n\nIn order to understand what is happening when you call Python Fire, it can be\nuseful to request a trace. This is done via the --trace flag, e.g.\n\nwidget whack 5 -- --trace\n.\n\n\nA trace provides step by step information about how the Fire command was\nexecuted. In includes which actions were taken, starting with the initial\ncomponent, leading to the final component represented by the command.\n\n\nA trace is also shown alongside the help if your Fire command reaches an error.\n\n\n--separator\n: Changing the separator \n\n\nAs described in \nCalling a Function\n, you can use a\nseparator argument when writing a command that corresponds to calling a\nfunction. The separator will cause the function to be evaluated or the class to\nbe instantiated using only the arguments left of the separator. Arguments right\nof the separator will then be applied to the result of the function call or to\nthe instantiated object.\n\n\nThe default separator is \n-\n.\n\n\nIf you want to supply the string \"-\" as an argument, then you will have to\nchange the separator. You can choose a new separator by supplying the\n\n--separator\n flag to Fire.\n\n\nHere's an example to demonstrate separator usage. Let's say you have a function\nthat takes a variable number of args, and you want to call that function, and\nthen upper case the result. Here's how to do it:\n\n\n# Here's the Python function\ndef display(arg1, arg2='!'):\n  return arg1 + arg2\n\n\n\n\n# Here's what you can do from Bash (Note: the default separator is the hyphen -)\ndisplay hello                         # hello!\ndisplay hello upper                   # helloupper\ndisplay hello - upper                 # HELLO!\ndisplay - SEP upper -- --separator SEP    # -!\n\n\n\n\nNotice how in the third and fourth lines, the separator caused the display\nfunction to be called with the default value for arg2. In the fourth example,\nwe change the separator to the string \"SEP\" so that we can pass '-' as an\nargument.\n\n\n--verbose\n: Verbose usage \n\n\nAdding the \n-v\n or \n--verbose\n flag turns on verbose mode. This will eg\nreveal private members in the usage string. Often these members will not\nactually be usable from the command line tool. As such, verbose mode should be\nconsidered a debugging tool, but not fully supported yet.", 
            "title": "Using a CLI"
        }, 
        {
            "location": "/using-cli/#using-a-fire-cli", 
            "text": "", 
            "title": "Using a Fire CLI"
        }, 
        {
            "location": "/using-cli/#basic-usage", 
            "text": "Every Fire command corresponds to a Python component.  The simplest Fire command consists of running your program with no additional\narguments. This command corresponds to the Python component you called the Fire  function on. If you did not supply an object in the call to  Fire , then\nthe context in which  Fire  was called will be used as the Python component.  You can append  -- --help  to any command to see what Python component it\ncorresponds to, as well as the various ways in which you can extend the command.\nFlags are always separated from the Fire command by an isolated  --  in order\nto distinguish between flags and named arguments.  Given a Fire command that corresponds to a Python object, you can extend that\ncommand to access a member of that object, call it with arguments if it is a\nfunction, instantiate it if it is a class, or index into it if it is a list.  Read on to learn about how you can write a Fire command corresponding to\nwhatever Python component you're looking for.", 
            "title": "Basic usage"
        }, 
        {
            "location": "/using-cli/#accessing-members-of-an-object", 
            "text": "If your command corresponds to an object, you can extend your command by adding\nthe name of a member of that object as a new argument to the command. The\nresulting command will correspond to that member.  For example, if the object your command corresponds to has a method defined on\nit named 'whack', then you can add the argument 'whack' to your command, and the\nresulting new command corresponds to the whack method.  As another example, if the object your command corresponds to has a property\nnamed high_score, then you can add the argument 'high-score' to your command,\nand the resulting new command corresponds to the value of the high_score\nproperty.", 
            "title": "Accessing members of an object"
        }, 
        {
            "location": "/using-cli/#accessing-members-of-a-dict", 
            "text": "If your command corresponds to a dict, you can extend your command by adding\nthe name of one of the dict's keys as an argument.  For example,  widget function-that-returns-dict key  will correspond to the\nvalue of the item with key  key  in the dict returned by function_that_returns_dict .", 
            "title": "Accessing members of a dict"
        }, 
        {
            "location": "/using-cli/#accessing-members-of-a-list-or-tuple", 
            "text": "If your command corresponds to a list or tuple, you can extend your command by\nadding the index of an element of the component to your command as an argument.  For example,  widget function-that-returns-list 2  will correspond to item 2 of\nthe result of function_that_returns_list.", 
            "title": "Accessing members of a list or tuple"
        }, 
        {
            "location": "/using-cli/#calling-a-function", 
            "text": "If your command corresponds to a function, you can extend your command by adding\nthe arguments of this function. Arguments can be specified positionally, or by\nname. To specify an argument by name, use flag syntax.  For example, suppose your  command  corresponds to the function  double :  def double(value=0):\n  return 2 * value  Then you can extend your command using named arguments as  command --value 5 ,\nor using positional arguments as  command 5 . In both cases, the new command\ncorresponds to the result of the function, in this case the number 10.  You can force a function that takes a variable number of arguments to be\nevaluated by adding a separator (the default separator is the hyphen, \"-\"). This\nwill prevent arguments to the right of the separator from being consumed for\ncalling the function. This is useful if the function has arguments with default\nvalues, or if the function accepts *varargs, or if the function accepts\n**kwargs.  See also the section on  Changing the Separator .", 
            "title": "Calling a function"
        }, 
        {
            "location": "/using-cli/#instantiating-a-class", 
            "text": "If your command corresponds to a class, you can extend your command by adding\nthe arguments of the class's __init__ function. Arguments must be specified\nby name, using the flags syntax. See the section on calling a function  for more details.", 
            "title": "Instantiating a class"
        }, 
        {
            "location": "/using-cli/#using-flags-with-fire-clis", 
            "text": "Command line arguments to a Fire CLI are normally consumed by Fire, as described\nin the  Basic Usage  section. In order to set Flags, put the flags\nafter the final standalone  --  argument. (If there is no  --  argument, then no\narguments are used for flags.)  For example, to set the alsologtostderr flag, you could run the command: widget bang --noise=boom -- --alsologtostderr . The --noise argument is\nconsumed by Fire, but the --alsologtostderr argument is treated as a normal\nFlag.  All CLIs built with Python Fire share some flags, as described in the next\nsections.", 
            "title": "Using Flags with Fire CLIs "
        }, 
        {
            "location": "/using-cli/#python-fires-flags", 
            "text": "As described in the  Using Flags  section, you must add an\nisolated  --  argument in order to have arguments treated as Flags rather than\nbe consumed by Python Fire. All arguments to a Fire CLI after the final\nstandalone  --  argument are treated as Flags.  The following flags are accepted by all Fire CLIs: --interactive / -i , --help / -h , --separator , --completion , --trace ,\nand  --verbose / -v ,\nas described in the following sections.", 
            "title": "Python Fire's Flags"
        }, 
        {
            "location": "/using-cli/#-interactive-interactive-mode", 
            "text": "Call  widget -- --interactive  or  widget -- -i  to enter interactive mode. This\nwill put you in an IPython REPL, with the variable  widget  already defined.  You can then explore the Python object that  widget  corresponds to\ninteractively using Python.", 
            "title": "--interactive: Interactive mode "
        }, 
        {
            "location": "/using-cli/#-completion-generating-a-completion-script", 
            "text": "Call  widget -- --completion  to generate a completion script for the Fire CLI widget . To save the completion script to your home directory, you could e.g.\nrun  widget -- --completion   ~/.widget-completion . You should then source this\nfile; to get permanent completion, source this file from your .bashrc file.  If the commands available in the Fire CLI change, you'll have to regenerate the\ncompletion script and source it again.", 
            "title": "--completion: Generating a completion script "
        }, 
        {
            "location": "/using-cli/#-help-getting-help", 
            "text": "Let say you have a command line tool named  widget  that was made with Fire. How\ndo you use this Fire CLI?  The simplest way to get started is to run  widget -- --help . This will give you\nusage information for your CLI. You can always append  -- --help  to any Fire\ncommand in order to get usage information for that command and any subcommands.  Additionally, help will be displayed if you hit an error using Fire. For\nexample, if you try to pass too many or too few arguments to a function, then\nhelp will be displayed. Similarly, if you try to access a member that does not\nexist, or if you index into a list with too high an index, then help will be\ndisplayed.  The displayed help shows information about which Python component your command\ncorresponds to, as well as usage information for how to extend that command.", 
            "title": "--help: Getting help "
        }, 
        {
            "location": "/using-cli/#-trace-getting-a-fire-trace", 
            "text": "In order to understand what is happening when you call Python Fire, it can be\nuseful to request a trace. This is done via the --trace flag, e.g. widget whack 5 -- --trace .  A trace provides step by step information about how the Fire command was\nexecuted. In includes which actions were taken, starting with the initial\ncomponent, leading to the final component represented by the command.  A trace is also shown alongside the help if your Fire command reaches an error.", 
            "title": "--trace: Getting a Fire trace "
        }, 
        {
            "location": "/using-cli/#-separator-changing-the-separator", 
            "text": "As described in  Calling a Function , you can use a\nseparator argument when writing a command that corresponds to calling a\nfunction. The separator will cause the function to be evaluated or the class to\nbe instantiated using only the arguments left of the separator. Arguments right\nof the separator will then be applied to the result of the function call or to\nthe instantiated object.  The default separator is  - .  If you want to supply the string \"-\" as an argument, then you will have to\nchange the separator. You can choose a new separator by supplying the --separator  flag to Fire.  Here's an example to demonstrate separator usage. Let's say you have a function\nthat takes a variable number of args, and you want to call that function, and\nthen upper case the result. Here's how to do it:  # Here's the Python function\ndef display(arg1, arg2='!'):\n  return arg1 + arg2  # Here's what you can do from Bash (Note: the default separator is the hyphen -)\ndisplay hello                         # hello!\ndisplay hello upper                   # helloupper\ndisplay hello - upper                 # HELLO!\ndisplay - SEP upper -- --separator SEP    # -!  Notice how in the third and fourth lines, the separator caused the display\nfunction to be called with the default value for arg2. In the fourth example,\nwe change the separator to the string \"SEP\" so that we can pass '-' as an\nargument.", 
            "title": "--separator: Changing the separator "
        }, 
        {
            "location": "/using-cli/#-verbose-verbose-usage", 
            "text": "Adding the  -v  or  --verbose  flag turns on verbose mode. This will eg\nreveal private members in the usage string. Often these members will not\nactually be usable from the command line tool. As such, verbose mode should be\nconsidered a debugging tool, but not fully supported yet.", 
            "title": "--verbose: Verbose usage "
        }, 
        {
            "location": "/troubleshooting/", 
            "text": "Troubleshooting\n\n\nThis page describes known issues that users of Python Fire have run into. If you\nhave an issue not resolved here, consider opening a\n\nGitHub Issue\n.\n\n\nIssue \n#19\n: Don't name your module \"cmd\"\n\n\nIf you have a module name that conflicts with the name of a builtin module, then\nwhen Fire goes to import the builtin module, it will import your module instead.\nThis will result in an error, possibly an \nAttributeError\n. Specifically, do not\nname your module any of the following:\nsys, linecache, cmd, bdb, repr, os, re, pprint, traceback", 
            "title": "Troubleshooting"
        }, 
        {
            "location": "/troubleshooting/#troubleshooting", 
            "text": "This page describes known issues that users of Python Fire have run into. If you\nhave an issue not resolved here, consider opening a GitHub Issue .", 
            "title": "Troubleshooting"
        }, 
        {
            "location": "/troubleshooting/#issue-19-dont-name-your-module-cmd", 
            "text": "If you have a module name that conflicts with the name of a builtin module, then\nwhen Fire goes to import the builtin module, it will import your module instead.\nThis will result in an error, possibly an  AttributeError . Specifically, do not\nname your module any of the following:\nsys, linecache, cmd, bdb, repr, os, re, pprint, traceback", 
            "title": "Issue #19: Don't name your module \"cmd\""
        }, 
        {
            "location": "/api/", 
            "text": "Setup\n\n\nCommand\n\n\nNotes\n\n\n\n\n\n\n\n\n\n\ninstall\n\n\npip install fire\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCreating a CLI\n\n\nCommand\n\n\nNotes\n\n\n\n\n\n\n\n\n\n\nimport\n\n\nimport fire\n\n\n\n\n\n\n\n\nCall\n\n\nfire.Fire()\n\n\nTurns the current module into a Fire CLI.\n\n\n\n\n\n\nCall\n\n\nfire.Fire(component)\n\n\nTurns \ncomponent\n into a Fire CLI.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nUsing a CLI\n\n\nCommand\n\n\nNotes\n\n\n\n\n\n\n\n\n\n\nHelp\n\n\ncommand -- --help\n\n\n\n\n\n\n\n\nREPL\n\n\ncommand -- --interactive\n\n\nEnters interactive mode.\n\n\n\n\n\n\nSeparator\n\n\ncommand -- --separator=X\n\n\nThis sets the separator to \nX\n. The default separator is \n-\n.\n\n\n\n\n\n\nCompletion\n\n\ncommand -- --completion\n\n\nGenerate a completion script for the CLI.\n\n\n\n\n\n\nTrace\n\n\ncommand -- --trace\n\n\nGets a Fire trace for the command.\n\n\n\n\n\n\nVerbose\n\n\ncommand -- --verbose\n\n\n\n\n\n\n\n\n\n\nNote that flags are separated from the Fire command by an isolated \n--\n arg.", 
            "title": "Reference"
        }
    ]
}